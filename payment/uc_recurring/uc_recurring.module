<?php
// $Id$

/**
 * @file
 * Allows you to add a recurring fee to a product/SKU to handle subscription
 *   type services.
 *
 * This module includes code for the recurring fee product feature and a default
 * recurring fee handler.  The default handler simply adds fees to the queue to
 * be processed on cron runs.  Initial charges, even if they're set to occur in
 * 0 days will not be processed immediately upon checkout
 */


/*******************************************************************************
 * Drupal Hooks
 ******************************************************************************/

/**
 * Implementation of hook_menu().
 */
function uc_recurring_menu($may_cache) {
  if ($may_cache) {
    $items[] = array(
      'path' => 'admin/store/orders/recurring',
      'title' => t('Recurring fees'),
      'description' => t('View the recurring fees on your orders.'),
      'callback' => 'uc_recurring_admin',
      'access' => user_access('administer recurring fees'),
      'type' => MENU_NORMAL_ITEM,
      'weight' => 5,
    );
  }
  else {
    if (arg(3) == 'recurring' && intval(arg(4)) > 0) {
      if (arg(5) == 'charge') {
        $items[] = array(
          'path' => 'admin/store/orders/recurring/'. arg(4) .'/charge',
          'title' => t('Charge recurring fee !fee?', array('!fee' => arg(4))),
          'callback' => 'drupal_get_form',
          'callback arguments' => array('uc_recurring_admin_charge_form'),
          'access' => user_access('administer recurring fees'),
          'type' => MENU_CALLBACK,
        );
      }
      elseif (arg(5) == 'edit') {
        $items[] = array(
          'path' => 'admin/store/orders/recurring/'. arg(4) .'/edit',
          'title' => t('Edit recurring fee !fee', array('!fee' => arg(4))),
          'callback' => 'drupal_get_form',
          'callback arguments' => array('uc_recurring_admin_edit_form'),
          'access' => user_access('administer recurring fees'),
          'type' => MENU_CALLBACK,
        );
      }
      elseif (arg(5) == 'delete') {
        $items[] = array(
          'path' => 'admin/store/orders/recurring/'. arg(4) .'/delete',
          'title' => t('Delete recurring fee !fee?', array('!fee' => arg(4))),
          'callback' => 'drupal_get_form',
          'callback arguments' => array('uc_recurring_admin_delete_form'),
          'access' => user_access('administer recurring fees'),
          'type' => MENU_CALLBACK,
        );
      }
    }
  }

  return $items;
}

/**
 * Implementation of hook_perm().
 */
function uc_recurring_perm() {
  return array('administer recurring fees');
}

/**
 * Implementation of hook_form_alter().
 */
function uc_recurring_form_alter($form_id, &$form) {
  // We may need to alter the checkout form to remove invalid payment methods.
  if ($form_id == 'uc_cart_checkout_form' && isset($form['panes']['payment'])) {
    $order->products = uc_cart_get_contents();

    // Make no changes if no recurring fees are found.
    if (uc_recurring_find_fees($order) == array()) {
      return;
    }

    // Remove invalid payment methods from the payment pane.
    $valid = variable_get('uc_recurring_payment_methods', array());
    foreach (array_keys($form['panes']['payment']['payment_method']['#options']) as $key) {
      if (!isset($valid[$key]) || $valid[$key] === 0) {
        unset($form['panes']['payment']['payment_method']['#options'][$key]);
      }
    }

    $count = count($form['panes']['payment']['payment_method']['#options']);
    if ($count == 0) {
      // Display an error message if no payment methods remain.
      drupal_set_message(t('There are no payment methods configured for orders with recurring fees!'), 'error');
      drupal_set_message(t('Please contact an administrator to solve the issue.'), 'error');
    }
    elseif ($count == 1) {
      // If only one payment method remains, make it the default.
      $form['panes']['payment']['payment_method']['#default_value'] = array_pop(array_keys($form['panes']['payment']['payment_method']['#options']));
    }
  }
}

/**
 * Implementation of hook_cron().
 */
function uc_recurring_cron() {
  if (variable_get('uc_recurring_handler', 'uc_recurring') == 'uc_recurring') {
    $successes = 0;
    $fails = 0;

    $result = db_query("SELECT * FROM {uc_recurring_users} WHERE remaining_intervals > 0 AND next_charge <= %d", time());
    while ($fee = db_fetch_array($result)) {
      $fee['data'] = unserialize($fee['data']);

      if ($key = uc_credit_encryption_key()) {
        $crypt = new uc_encryption_class;
        $fee['data']['payment_details']['cc_number'] = $crypt->decrypt($key, $fee['data']['payment_details']['cc_number']);
        $fee['data']['payment_details']['cc_cvv'] = $crypt->decrypt($key, $fee['data']['payment_details']['cc_cvv']);
        $fee['data']['payment_details']['cc_exp_month'] = $crypt->decrypt($key, $fee['data']['payment_details']['cc_exp_month']);
        $fee['data']['payment_details']['cc_exp_year'] = $crypt->decrypt($key, $fee['data']['payment_details']['cc_exp_year']);
        uc_store_encryption_errors($crypt, 'uc_recurring');
      }

      // Attempt to process the charge.
      if (uc_recurring_charge($fee)) {
        // Update the fee in the database.
        if ($fee['remaining_intervals'] == 1) {
          $next_charge = time();
        }
        else {
          $next_charge = strtotime('+'. $fee['regular_interval']);
        }
        db_query("UPDATE {uc_recurring_users} SET next_charge = %d, remaining_intervals = remaining_intervals - 1, charged_intervals = charged_intervals + 1 WHERE rfid = %d", $next_charge, $fee['rfid']);
        $successes++;
      }
      else {
        $fails++;
      }
    }

    if ($successes > 0 || $fails > 0) {
      watchdog('uc_recurring', t('!successes recurring fees processed successfully; !fails failed.', array('!successes' => $successes, '!fails' => $fails)));
    }
  }
}


/*******************************************************************************
 * Ubercart Hooks
 ******************************************************************************/

/**
 * Implementation of hook_order().
 */
function uc_recurring_order($op, &$arg1, $arg2) {
  switch ($op) {
    case 'submit':
      if (variable_get('uc_recurring_checkout_process', TRUE)) {
        $fees = uc_recurring_find_fees($arg1);
        if (count($fees)) {
          $pass = TRUE;
          foreach ($fees as $fee) {
            if (!uc_recurring_process($arg1, $fee)) {
              uc_order_comment_save($arg1->order_id, 0, t('The recurring fee for product !model failed.', array('!model' => $fee->model)), 'admin', $order->order_status);
              $pass = FALSE;
            }
          }
          if ($pass == FALSE) {
            $process = variable_get('uc_recurring_checkout_fail', 'fail');
            if ($process == 'fail' && uc_payment_balance($arg1) < $arg1->order_total) {
              $process = 'proceed';
            }
            switch ($process) {
              case 'fail':
                return array(array('pass' => FALSE, 'message' => t('Your order cannot be completed, because we could not process your recurring payment. Please review your payment details and contact us to complete your order if the problem persists.')));
              case 'proceed':
                return array(array('pass' => TRUE, 'message' => t('Your order has been submitted, but we may need to contact you to ensure your recurring fee is setup properly. Thank you for your understanding.')));
            }
          }
        }
      }
      break;

    case 'update':
      if (uc_order_status_data($arg1->order_status, 'state') == 'in_checkout') {
        db_query("UPDATE {uc_recurring_users} SET uid = %d WHERE uid = 0 AND order_id = %d", $arg1->uid, $arg1->order_id);
      }
  }
}

/**
 * Implementation of hook_product_feature().
 */
function uc_recurring_product_feature() {
  $features[] = array(
    'id' => 'recurring',
    'title' => t('Recurring fee'),
    'callback' => 'uc_recurring_feature_form',
    'delete' => 'uc_recurring_fee_delete',
    'settings' => 'uc_recurring_settings_form',
  );

  return $features;
}

/**
 * Implementation of hook_recurring_fee(); default recurring fee handler.
 */
function uc_recurring_recurring_fee($order, $fee) {
  if ($order->payment_method !== 'credit') {
    watchdog('uc_recurring', t('You can only use the credit card payment method with the uc_recurring handler.'), WATCHDOG_ERROR);
    return FALSE;
  }

  $data = array(
    'billing_first_name' => $order->billing_first_name,
    'billing_last_name' => $order->billing_last_name,
    'billing_phone' => $order->billing_phone,
    'billing_company' => $order->billing_company,
    'billing_street1' => $order->billing_street1,
    'billing_street2' => $order->billing_street2,
    'billing_city' => $order->billing_city,
    'billing_zone' => $order->billing_zone,
    'billing_postal_code' => $order->billing_postal_code,
    'billing_country' => $order->billing_country,
    'payment_details' => $order->payment_details,
    'model' => $fee->model,
  );

  if ($key = uc_credit_encryption_key()) {
    $crypt = new uc_encryption_class;
    $data['payment_details']['cc_number'] = $crypt->encrypt($key, $data['payment_details']['cc_number'], 32);
    $data['payment_details']['cc_cvv'] = $crypt->encrypt($key, $data['payment_details']['cc_cvv'], 32);
    $data['payment_details']['cc_exp_month'] = $crypt->encrypt($key, $data['payment_details']['cc_exp_month'], 32);
    $data['payment_details']['cc_exp_year'] = $crypt->encrypt($key, $data['payment_details']['cc_exp_year'], 32);
    uc_store_encryption_errors($crypt, 'uc_recurring');
  }

  $fee = array(
    'rfid' => db_next_id('{uc_product_users}_rfid'),
    'uid' => $order->uid,
    'next_charge' => strtotime('+'. $fee->initial_charge),
    'fee_amount' => $fee->fee_amount,
    'regular_interval' => $fee->regular_interval,
    'remaining_intervals' => $fee->number_intervals,
    'charged_intervals' => 0,
    'order_id' => $order->order_id,
    'data' => serialize($data),
  );

  uc_recurring_fee_save('user', $fee);

  uc_order_comment_save($order->order_id, 0, t('Recurring fee <a href="!url">!fee</a> added to order.', array('!url' => url('admin/store/orders/recurring/view/fee/'. $fee['rfid']), '!fee' => $fee['rfid'])));

  return TRUE;
}


/******************************************************************************
 * Workflow-ng Hooks                                                          *
 ******************************************************************************/

// Tell Workflow about the various order events.
function uc_recurring_event_info() {
  $events['fee_expires'] = array(
    '#label' => t('Recurring payment expires'),
    '#module' => t('Recurring Payments'),
    '#arguments' => array(
      'order' => array('#entity' => 'order', '#lable' => t('Order')),
    ),
  );
  $events['fee_charge_successful'] = array(
    '#label' => t('Payment is charged successfully'),
    '#module' => t('Recurring Payments'),
    '#arguments' => array(
      'order' => array('#entity' => 'order', '#lable' => t('Order')),
    ),
  );
  $events['fee_charge_fails'] = array(
    '#label' => t('Payment charge fails'),
    '#module' => t('Recurring Payments'),
    '#arguments' => array(
      'order' => array('#entity' => 'order', '#lable' => t('Order')),
    ),
  );

  return $events;
}


/*******************************************************************************
 * Callback Functions
 ******************************************************************************/

// Builds the form to display for adding or editing a recurring fee.
function uc_recurring_feature_form($node, $feature) {
  drupal_add_css(drupal_get_path('module', 'uc_recurring') .'/uc_recurring.css');

  if (!empty($feature)) {
    $fee = uc_recurring_fee_load('product', $feature['pfid']);
  }

  $options = array('' => t('<Any>'), $node->model => $node->model);
  if (module_exists('uc_attribute')) {
    $result = db_query("SELECT model FROM {uc_product_adjustments} WHERE nid = %d", $node->nid);
    while ($row = db_fetch_object($result)) {
      if (!in_array($row->model, $options)) {
        $options[$row->model] = $row->model;
      }
    }
  }
  $form['model'] = array(
    '#type' => 'select',
    '#title' => t('Applicable Model/SKU'),
    '#description' => t('Select the applicable product model/SKU for this fee.'),
    '#options' => $options,
    '#default_value' => $fee['model'],
  );

  $form['fee_amount'] = array(
    '#type' => 'textfield',
    '#title' => t('Recurring fee amount'),
    '#description' => t('Charge this amount each billing period.<br />The product price is still charged at checkout.'),
    '#default_value' => $fee['fee_amount'],
    '#size' => 16,
    '#field_prefix' => variable_get('uc_sign_after_amount', FALSE) ? '' : variable_get('uc_currency_sign', '$'),
    '#field_suffix' => variable_get('uc_sign_after_amount', FALSE) ? variable_get('uc_currency_sign', '$') : '',
  );

  $form['initial'] = array(
    '#type' => 'fieldset',
    '#title' => t('Initial charge'),
    '#collapsible' => FALSE,
    '#description' => t('Specify the time to wait to start charging the recurring fee after checkout. Remember the product price will be charged at the time of checkout.'),
    '#attributes' => array('class' => 'interval-fieldset'),
  );
  $form['initial']['initial_charge_value'] = array(
    '#type' => 'select',
    '#options' => drupal_map_assoc(uc_range(0, 52)),
    '#default_value' => $fee['initial_charge_value'],
  );
  $form['initial']['initial_charge_unit'] = array(
    '#type' => 'select',
    '#options' => array(
      'days' => t('day(s)'),
      'weeks' => t('week(s)'),
      'months' => t('month(s)'),
      'years' => t('year(s)'),
    ),
    '#default_value' => $fee['initial_charge_unit'],
  );

  $form['regular'] = array(
    '#type' => 'fieldset',
    '#title' => t('Regular interval'),
    '#collapsible' => FALSE,
    '#description' => t('Specify the length of the billing period for this fee.'),
    '#attributes' => array('class' => 'interval-fieldset'),
  );
  $form['regular']['regular_interval_value'] = array(
    '#type' => 'select',
    '#options' => drupal_map_assoc(uc_range(1, 52)),
    '#default_value' => $fee['regular_interval_value'],
  );
  $form['regular']['regular_interval_unit'] = array(
    '#type' => 'select',
    '#options' => array(
      'days' => t('day(s)'),
      'weeks' => t('week(s)'),
      'months' => t('month(s)'),
      'years' => t('year(s)'),
    ),
    '#default_value' => $fee['regular_interval_unit'],
  );

  $form['number_intervals'] = array(
    '#type' => 'textfield',
    '#title' => t('Number of billing periods'),
    '#description' => t('Specify how many times the recurring fee will be charged.'),
    '#size' => 16,
    '#default_value' => $fee['number_intervals'],
  );

  return uc_product_feature_form($form);
}

function uc_recurring_feature_form_validate($form_id, $form_values) {
  if (!empty($form_values['number_intervals']) && !is_int($form_values['number_intervals']) && $form_values['number_intervals'] < 0) {
    form_set_error('number_intervals', t('Valid entries for the number of intervals are 0 for indefinite or a positive whole number.'));
  }
}

function uc_recurring_feature_form_submit($form_id, $form_values) {
  if (empty($form_values['pfid'])) {
    $fee['pfid'] = db_next_id('{uc_product_features}_pfid');
  }
  else {
    $fee['pfid'] = $form_values['pfid'];
  }

  $fee = array(
    'pfid' => $fee['pfid'],
    'model' => $form_values['model'],
    'fee_amount' => $form_values['fee_amount'],
    'initial_charge' => $form_values['initial_charge_value'] .' '. $form_values['initial_charge_unit'],
    'regular_interval' => $form_values['regular_interval_value'] .' '. $form_values['regular_interval_unit'],
    'number_intervals' => intval($form_values['number_intervals']),
  );
  uc_recurring_fee_save('product', $fee);

  $args = array(
    '!product' => empty($fee['model']) ? t('this product') : t('product !model', array('!model' => $fee['model'])),
    '!amount' => uc_currency_format($fee['fee_amount']),
    '!initial' => $fee['initial_charge'],
    '!regular' => $fee['regular_interval'],
    '!intervals' => $fee['number_intervals'] == 0 ? t('indefinitely') : t('!num times', array('!num' => $fee['number_intervals'] - 1)),
  );

  $data = array(
    'pfid' => $fee['pfid'],
    'nid' => $form_values['nid'],
    'fid' => 'recurring',
    'description' => t('When !product is purchased, add a fee for !amount charged first after !initial and every !regular after that !intervals.', $args),
  );
  
  return uc_product_feature_save($data);
}

// Adds the settings for the recurring module on the feature settings form.
function uc_recurring_settings_form() {
  $form['uc_recurring_handler'] = array(
    '#type' => 'select',
    '#title' => t('Recurring fee handler'),
    '#description' => t('Select a module to process recurring fees on your site.'),
    '#options' => drupal_map_assoc(module_implements('recurring_fee', TRUE)),
    '#default_value' => variable_get('uc_recurring_handler', 'uc_recurring'),
  );
  foreach (_payment_method_list() as $method) {
    $options[$method['id']] = $method['name'];
  }
  $form['uc_recurring_payment_methods'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Valid payment methods for orders with recurring fees'),
    '#description' => t('Only selected payment methods will be available for customers purchasing products with recurring fees.<br/>It is up to you to make sure your chosen handler is compatible with the payment methods you select.<br />For example, the uc_recurring handler is only compatible with the Credit Card payment method.'),
    '#options' => $options,
    '#default_value' => variable_get('uc_recurring_payment_methods', array()),
  );
  $form['uc_recurring_checkout_process'] = array(
    '#type' => 'checkbox',
    '#title' => t('Attempt to process recurring fees during checkout.'),
    '#default_value' => variable_get('uc_recurring_checkout_process', TRUE),
  );
  $form['uc_recurring_checkout_fail'] = array(
    '#type' => 'radios',
    '#title' => t('Action to take if a recurring fee fails to process during checkout'),
    '#description' => t('Regardless of your selection, an admin comment will report the failure.<br/><strong>Note:</strong> Even if you select the first option, checkout will complete if another payment has already been captured.'),
    '#options' => array(
      'fail' => t('Return a failed message and do not complete checkout.'),
      'proceed' => t('Return a failed message but complete checkout.'),
      'silent' => t('Show no message and complete checkout.'),
    ),
    '#default_value' => variable_get('uc_recurring_checkout_fail', 'fail'),
  );

  return $form;
}

function uc_recurring_admin() {
  $output = drupal_get_form('uc_recurring_admin_filter_form');

  $header = array(
    array('data' => t('ID'), 'field' => 'ru.rfid'),
    array('data' => t('Order'), 'field' => 'ru.order_id'),
    array('data' => t('Amount'), 'field' => 'ru.fee_amount'),
    array('data' => t('Next'), 'field' => 'ru.next_charge', 'sort' => 'desc'),
    array('data' => t('Interval'), 'field' => 'ru.regular_interval'),
    array('data' => t('Left'), 'field' => 'ru.remaining_intervals'),
    array('data' => t('Total')),
    array('data' => t('Operations')),
  );

  if (arg(4) == 'view' && intval(arg(6)) > 0) {
    if (arg(5) == 'fee') {
      $result = db_query("SELECT * FROM {uc_recurring_users} AS ru WHERE ru.rfid = %d", arg(6));
    }
    elseif (arg(5) == 'order') {
      $result = db_query("SELECT * FROM {uc_recurring_users} AS ru WHERE ru.order_id = %d", arg(6));
    }
  }
  else {
    $result = pager_query("SELECT * FROM {uc_recurring_users} AS ru" . tablesort_sql($header), 30);
  }

  while ($fee = db_fetch_array($result)) {
    $ops = array();
    if ($fee['remaining_intervals'] > 0) {
      $ops[] = l(t('charge'), 'admin/store/orders/recurring/'. $fee['rfid'] .'/charge');
    }
    $ops[] = l(t('edit'), 'admin/store/orders/recurring/'. $fee['rfid'] .'/edit');
    $ops[] = l(t('delete'), 'admin/store/orders/recurring/'. $fee['rfid'] .'/delete');

    $rows[] = array(
      l($fee['rfid'], 'admin/store/orders/recurring/view/fee/'. $fee['rfid']),
      l($fee['order_id'], 'admin/store/orders/'. $fee['order_id']),
      uc_currency_format($fee['fee_amount']),
      $fee['remaining_intervals'] == 0 ? '-' : format_date($fee['next_charge'], 'small'),
      array('data' => check_plain($fee['regular_interval']), 'nowrap' => 'nowrap'),
      $fee['remaining_intervals'],
      $fee['remaining_intervals'] + $fee['charged_intervals'],
      array('data' => implode(' ', $ops), 'nowrap' => 'nowrap'),
    );
  }

  $output .= theme('table', $header, $rows);
  $output .= theme('pager', NULL, 30, 0);

  if (arg(4) == 'view') {
    $output .= l(t('Back to the full list.'), 'admin/store/orders/recurring');
  }

  return $output;
}

// Filter by a specific order ID.
function uc_recurring_admin_filter_form() {
  $form['type'] = array(
    '#type' => 'select',
    '#options' => array(
      'order' => t('Order ID'),
      'fee' => t('Fee ID'),
    ),
    '#default_value' => arg(5) == 'fee' ? 'fee' : 'order',
    '#prefix' => '<div style="float: left; margin-right: 1em;">',
    '#suffix' => '</div>',
  );
  $form['id'] = array(
    '#type' => 'textfield',
    '#size' => 10,
    '#prefix' => '<div style="float: left; margin-right: 1em;">',
    '#suffix' => '</div>',
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Filter'),
    '#attributes' => array('style' => 'margin: .85em 0em;'),
  );

  return $form;
}

function uc_recurring_admin_filter_form_submit($form_id, $form_values) {
  if (intval($form_values['id']) > 0) {
    return 'admin/store/orders/recurring/view/'. $form_values['type'] .'/'. $form_values['id'];
  }
}

// Confirm a recurring fee charge.
function uc_recurring_admin_charge_form() {
  $fee = uc_recurring_fee_load('user', arg(4));
  $form['message'] = array(
    '#value' => '<div>'. t('Are you sure you want to charge the customer !amount at this time?', array('!amount' => uc_currency_format($fee['fee_amount']))) .'</div>',
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Charge'),
    '#suffix' => l(t('Cancel'), referer_uri(), NULL, NULL, TRUE),
  );
  return $form;
}

function uc_recurring_admin_charge_form_submit($form_id, $form_values) {
  $fee = uc_recurring_fee_load('user', arg(4));

  // Attempt to process the charge.
  if (uc_recurring_charge($fee)) {
    // Update the fee in the database.
    $next_charge = strtotime('+'. $fee['regular_interval']);
    db_query("UPDATE {uc_recurring_users} SET next_charge = %d, remaining_intervals = remaining_intervals - 1, charged_intervals = charged_intervals + 1 WHERE rfid = %d", $next_charge, $fee['rfid']);
    drupal_set_message(t('Recurring fee !fee charged successfully.', array('!fee' => arg(4))));
  }
  else {
    drupal_set_message(t('Attempt to charge recurring fee !fee failed.', array('!fee' => arg(4))), 'error');
  }

  return 'admin/store/orders/recurring/view/fee/'. arg(4);
}

// Let an admin edit a recurring fee.
function uc_recurring_admin_edit_form() {
  drupal_add_css(drupal_get_path('module', 'uc_recurring') .'/uc_recurring.css');

  $fee = uc_recurring_fee_load('user', arg(4));
  list($fee['regular_interval_value'], $fee['regular_interval_unit']) = explode(' ', $fee['regular_interval']);

  $form['fee_amount'] = array(
    '#type' => 'textfield',
    '#title' => t('Recurring fee amount'),
    '#description' => t('Charge this amount each billing period.'),
    '#default_value' => $fee['fee_amount'],
    '#size' => 16,
    '#field_prefix' => variable_get('uc_sign_after_amount', FALSE) ? '' : variable_get('uc_currency_sign', '$'),
    '#field_suffix' => variable_get('uc_sign_after_amount', FALSE) ? variable_get('uc_currency_sign', '$') : '',
  );

  $form['remaining_intervals'] = array(
    '#type' => 'textfield',
    '#title' => t('Remaining billing periods'),
    '#description' => t('Specify how many more times to charge the fee.'),
    '#size' => 16,
    '#default_value' => $fee['remaining_intervals'],
  );

  $form['regular'] = array(
    '#type' => 'fieldset',
    '#title' => t('Regular interval'),
    '#collapsible' => FALSE,
    '#description' => t('Modify the length of the billing period for this fee. Changing this value will reset the timer for the next charge. You can also charge the fee manually to collect payment ahead of time and reset the interval.'),
    '#attributes' => array('class' => 'interval-fieldset'),
  );
  $form['regular']['regular_interval_value'] = array(
    '#type' => 'select',
    '#options' => drupal_map_assoc(uc_range(1, 52)),
    '#default_value' => $fee['regular_interval_value'],
  );
  $form['regular']['regular_interval_unit'] = array(
    '#type' => 'select',
    '#options' => array(
      'days' => t('day(s)'),
      'weeks' => t('week(s)'),
      'months' => t('month(s)'),
      'years' => t('year(s)'),
    ),
    '#default_value' => $fee['regular_interval_unit'],
  );

  $form['reset_next_charge'] = array(
    '#type' => 'checkbox',
    '#title' => t('Reset the next charge timer upon form submission using the specified interval.'),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
    '#suffix' => l(t('Cancel'), referer_uri(), NULL, NULL, TRUE),
  );

  return $form;
}

function uc_recurring_admin_edit_form_submit($form_id, $form_values) {
  $interval = $form_values['regular_interval_value'] .' '. $form_values['regular_interval_unit'];

  db_query("UPDATE {uc_recurring_users} SET fee_amount = %f, regular_interval = '%s', "
          ."remaining_intervals = %d WHERE rfid = %d", $form_values['fee_amount'],
           $interval, $form_values['remaining_intervals'], arg(4));

  if ($form_values['reset_next_charge']) {
    $next_charge = strtotime('+'. $interval);
    db_query("UPDATE {uc_recurring_users} SET next_charge = %d WHERE rfid = %d", $next_charge, arg(4));
  }

  drupal_set_message(t('The changes to the fee have been saved.'));

  return 'admin/store/orders/recurring/view/fee/'. arg(4);
}

// Confirm a recurring fee deletion.
function uc_recurring_admin_delete_form() {
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Delete'),
    '#suffix' => l(t('Cancel'), referer_uri(), NULL, NULL, TRUE),
  );
  return $form;
}

function uc_recurring_admin_delete_form_submit($form_id, $form_values) {
  uc_recurring_fee_delete(array('fid' => arg(4)), 'user');

  drupal_set_message(t('Recurring fee !fee deleted.', array('!fee' => arg(4))));

  return 'admin/store/orders/recurring';
}

/**
 * Saves a recurring fee either for a product or for a user.
 */
function uc_recurring_fee_save($type, $data) {
  switch ($type) {
    case 'product':
      // First attempt to update an existing row.
      db_query("UPDATE {uc_recurring_products} SET model = '%s', "
              ."fee_amount = %f, initial_charge = '%s', regular_interval = '%s', "
              ."number_intervals = %d WHERE pfid = %d",
               $data['model'], $data['fee_amount'], $data['initial_charge'],
               $data['regular_interval'], $data['number_intervals'],
               $data['pfid']);

      // Otherwise insert this feature as a new row.
      if (db_affected_rows() == 0) {
        db_query("INSERT INTO {uc_recurring_products} VALUES (%d, '%s', %f, '%s', '%s', %d)",
                 $data['pfid'], $data['model'], $data['fee_amount'],
                 $data['initial_charge'], $data['regular_interval'],
                 $data['number_intervals']);
      }
      break;

    case 'user':
      // First attempt to update an existing row.
      db_query("UPDATE {uc_recurring_users} SET uid = %d, "
              ."next_charge = %d, fee_amount = %f, regular_interval = '%s', "
              ."remaining_intervals = %d, charged_intervals = %d, "
              ."data = '%s' WHERE rfid = %d",
               $data['uid'], $data['next_charge'], $data['fee_amount'],
               $data['regular_interval'], $data['remaining_intervals'],
               $data['charged_intervals'], $data['order_id'], $data['data'],
               $data['rfid']);

      // Otherwise insert this feature as a new row.
      if (db_affected_rows() == 0) {
        db_query("INSERT INTO {uc_recurring_users} VALUES (%d, %d, %d, %f, '%s', %d, %d, %d, '%s', %d)",
                 $data['rfid'], $data['uid'], $data['next_charge'],
                 $data['fee_amount'], $data['regular_interval'],
                 $data['remaining_intervals'], $data['charged_intervals'],
                 $data['order_id'], $data['data'], time());
      }
      break;
  }
}

/**
 * Loads a recurring fee either from a product or for a user.
 *
 * @param $type
 *   'product' to load a recurring fee product feature.
 *   'user' to load a recurring fee schedule for a user.
 * @param $id
 *   The ID of the fee to load, either the product feature ID or the recurring
 *     fee ID from the appropriate table.
 * @return
 *   An associative array of data for the specified fee.
 */
function uc_recurring_fee_load($type, $id) {
  switch ($type) {
    case 'product':
      $fee = db_fetch_array(db_query("SELECT * FROM {uc_recurring_products} WHERE pfid = %d", $id));
      if (!empty($fee)) {
        list($fee['initial_charge_value'], $fee['initial_charge_unit']) = explode(' ', $fee['initial_charge']);
        list($fee['regular_interval_value'], $fee['regular_interval_unit']) = explode(' ', $fee['regular_interval']);
      }
      break;
    case 'user':
      $fee = db_fetch_array(db_query("SELECT * FROM {uc_recurring_users} WHERE rfid = %d", $id));

      $fee['data'] = unserialize($fee['data']);

      if ($key = uc_credit_encryption_key()) {
        $crypt = new uc_encryption_class;
        $fee['data']['payment_details']['cc_number'] = $crypt->decrypt($key, $fee['data']['payment_details']['cc_number']);
        $fee['data']['payment_details']['cc_cvv'] = $crypt->decrypt($key, $fee['data']['payment_details']['cc_cvv']);
        $fee['data']['payment_details']['cc_exp_month'] = $crypt->decrypt($key, $fee['data']['payment_details']['cc_exp_month']);
        $fee['data']['payment_details']['cc_exp_year'] = $crypt->decrypt($key, $fee['data']['payment_details']['cc_exp_year']);
        uc_store_encryption_errors($crypt, 'uc_recurring');
      }
      break;
  }

  return $fee;
}

/**
 * Deletes a recurring fee from a product or user.
 *
 * @param $type
 *   Either 'product' or 'user' to specify what type of delete needs to happen.
 * @param $id
 *   The ID of the recurring fee to be removed from the appropriate table.
 */
function uc_recurring_fee_delete($feature, $type = 'product') {
  switch ($type) {
    case 'product':
      db_query("DELETE FROM {uc_recurring_products} WHERE pfid = %d", $feature['fid']);
      break;
    case 'user':
      module_invoke_all('recurring_api', 'delete', $feature['fid']);
      db_query("DELETE FROM {uc_recurring_users} WHERE rfid = %d", $feature['fid']);
      break;
  }
}

/**
 * Returns an array of recurring fees associated with any product on an order.
 *
 * @param $order
 *   The order object in question.
 * @return
 *   An array of recurring fee objects containing all their data from the DB.
 */
function uc_recurring_find_fees($order) {
  if (!is_array($order->products) || count($order->products) == 0) {
    return array();
  }

  foreach ($order->products as $product) {
    $models[] = check_plain($product->model);
  }

  $fees = array();
  $result = db_query("SELECT * FROM {uc_recurring_products} WHERE model IN ('". implode("', '", $models) ."')");
  while ($fee = db_fetch_object($result)) {
    $fees[] = $fee;
  }

  return $fees;
}

/**
 * Passes the information onto the specified fee handler for processing.
 *
 * @param $order
 *   The order object the fees are attached to.
 * @param $fee
 *   The fee object to be processed.
 * @return
 *   TRUE or FALSE indicating whether or not the processing was successful.
 */
function uc_recurring_process($order, $fee) {
  $handler = variable_get('uc_recurring_handler', 'uc_recurring') .'_recurring_fee';
  if (!function_exists($handler)) {
    drupal_set_message(t('The handler for processing recurring fees cannot be found.'), 'error');
    return FALSE;
  }

  if ($handler($order, $fee) == TRUE) {
    return TRUE;
  }

  return FALSE;
}

// Processes credit cards for the default handler.
function uc_recurring_charge($fee) {
  static $show = TRUE;

  // Get the charge function for the default credit card gateway.
  $gateways = _payment_gateway_list('credit', TRUE);
  if (count($gateways) == 1) {
    $keys = array_keys($gateways);
    $func = $gateways[$keys[0]]['credit'];
  }
  elseif (count($gateways) > 1) {
    foreach ($gateways as $gateway) {
      if ($gateway['id'] == variable_get('uc_payment_credit_gateway', '')) {
        $func = $gateway['credit'];
      }
    }
  }

  // Whoa... bad function? ABORT! ABORT!
  if (!function_exists($func)) {
    if ($show) {
      watchdog('uc_recurring', t('Recurring payments failed to process due to invalid credit card gateway.'), WATCHDOG_ERROR);
      $show = FALSE;
    }
    return FALSE;
  }

  // Run the charge.
  $result = $func($fee['order_id'], $fee['fee_amount'], NULL);

  // Handle the result.
  if ($result['success'] === TRUE) {
    uc_payment_enter($fee['order_id'], 'credit', $fee['fee_amount'], 0, $result['data'], t('Recurring fee payment.') .'<br />'. $result['comment']);
    uc_order_comment_save($fee['order_id'], 0, t('!amount recurring fee collected for !model. (ID: <a href="!url">!fee</a>)', array('!url' => url('admin/store/orders/recurring/view/fee/'. $fee['rfid']), '!fee' => $fee['rfid'], '!amount' => uc_currency_format($fee['fee_amount']), '!model' => $fee['data']['model'])));

    // Modules can hook into the charge process using hook_recurring_api().
    module_invoke_all('recurring_api', 'charge', $fee);

    // Provide a couple Workflow events for folks to hook into.
    workflow_ng_invoke_event('fee_charge_successful', uc_order_load($fee['order_id']));
    if ($fee['remaining_intervals'] == 1) {
      workflow_ng_invoke_event('fee_expires', uc_order_load($fee['order_id']));
    }
  }
  else {
    uc_order_comment_save($fee['order_id'], 0, t('Error: Recurring fee <a href="!url">!fee</a> for product !model failed.', array('!url' => url('admin/store/orders/recurring/view/fee/'. $fee['rfid']), '!fee' => $fee['rfid'], '!model' => $fee['data']['model'])));
    watchdog('uc_recurring', t('Failed to capture recurring fee of !amount for product !model on order !order_id.', array('!amount' => $fee['fee_amount'], '!model' => $fee['data']['model'], '!order_id' => $fee['order_id'])), WATCHDOG_ERROR, l(t('order !order_id', array('!order_id' => $fee['order_id'])), 'admin/store/orders/'. $fee['order_id']));

    // Modules can hook into the charge process using hook_recurring_api().
    module_invoke_all('recurring_api', 'fail', $fee);

    // Provide a Workflow event for folks to hook into.
    workflow_ng_invoke_event('fee_charge_fails', uc_order_load($fee['order_id']));
  }

  return $result['success'];
}
